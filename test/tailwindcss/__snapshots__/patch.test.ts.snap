// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`tailwindcss source code patch internalPatch case 0 1`] = `
""use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalize: ()=>normalize,
    url: ()=>url,
    number: ()=>number,
    percentage: ()=>percentage,
    length: ()=>length,
    lineWidth: ()=>lineWidth,
    shadow: ()=>shadow,
    color: ()=>color,
    image: ()=>image,
    gradient: ()=>gradient,
    position: ()=>position,
    familyName: ()=>familyName,
    genericName: ()=>genericName,
    absoluteSize: ()=>absoluteSize,
    relativeSize: ()=>relativeSize
});
const _color = require("./color");
const _parseBoxShadowValue = require("./parseBoxShadowValue");
const _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");
let cssFunctions = [
    "min",
    "max",
    "clamp",
    "calc"
];
// Ref: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types
function isCSSFunction(value) {
    return cssFunctions.some((fn)=>new RegExp(\`^\${fn}\\\\(.*\\\\)\`).test(value));
}
const placeholder = "--tw-placeholder";
const placeholderRe = new RegExp(placeholder, "g");
function normalize(value, isRoot = true) {
    // Keep raw strings if it starts with \`url(\`
    if (value.includes("url(")) {
        return value.split(/(url\\(.*?\\))/g).filter(Boolean).map((part)=>{
            if (/^url\\(.*?\\)$/.test(part)) {
                return part;
            }
            return normalize(part, false);
        }).join("");
    }
    // Convert \`_\` to \` \`, except for escaped underscores \`\\_\`
    value = value.replace(/([^\\\\])_+/g, (fullMatch, characterBefore)=>characterBefore + " ".repeat(fullMatch.length - 1)).replace(/^_/g, " ").replace(/\\\\_/g, "_");
    // Remove leftover whitespace
    if (isRoot) {
        value = value.trim();
    }
    // Add spaces around operators inside math functions like calc() that do not follow an operator
    // or '('.
    value = value.replace(/(calc|min|max|clamp)\\(.+\\)/g, (match)=>{
        let vars = [];
        return match.replace(/var\\((--.+?)[,)]/g, (match, g1)=>{
            vars.push(g1);
            return match.replace(g1, placeholder);
        }).replace(/(-?\\d*\\.?\\d(?!\\b-\\d.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g, "$1 $2 ").replace(placeholderRe, ()=>vars.shift());
    });
    return value;
}
function url(value) {
    return value.startsWith("url(");
}
function number(value) {
    return !isNaN(Number(value)) || isCSSFunction(value);
}
function percentage(value) {
    return value.endsWith("%") && number(value.slice(0, -1)) || isCSSFunction(value);
}
// Please refer to MDN when updating this list:
// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units
// https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries#container_query_length_units
let lengthUnits = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax", "rpx"];
let lengthUnitsPattern = \`(?:\${lengthUnits.join("|")})\`;
function length(value) {
    return value === "0" || new RegExp(\`^[+-]?[0-9]*\\.?[0-9]+(?:[eE][+-]?[0-9]+)?\${lengthUnitsPattern}$\`).test(value) || isCSSFunction(value);
}
let lineWidths = new Set([
    "thin",
    "medium",
    "thick"
]);
function lineWidth(value) {
    return lineWidths.has(value);
}
function shadow(value) {
    let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));
    for (let parsedShadow of parsedShadows){
        if (!parsedShadow.valid) {
            return false;
        }
    }
    return true;
}
function color(value) {
    let colors = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if ((0, _color.parseColor)(part, {
            loose: true
        }) !== null) return colors++, true;
        return false;
    });
    if (!result) return false;
    return colors > 0;
}
function image(value) {
    let images = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if (url(part) || gradient(part) || [
            "element(",
            "image(",
            "cross-fade(",
            "image-set("
        ].some((fn)=>part.startsWith(fn))) {
            images++;
            return true;
        }
        return false;
    });
    if (!result) return false;
    return images > 0;
}
let gradientTypes = new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
]);
function gradient(value) {
    value = normalize(value);
    for (let type of gradientTypes){
        if (value.startsWith(\`\${type}(\`)) {
            return true;
        }
    }
    return false;
}
let validPositions = new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
]);
function position(value) {
    let positions = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if (validPositions.has(part) || length(part) || percentage(part)) {
            positions++;
            return true;
        }
        return false;
    });
    if (!result) return false;
    return positions > 0;
}
function familyName(value) {
    let fonts = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        // If it contains spaces, then it should be quoted
        if (part.includes(" ")) {
            if (!/(['"])([^"']+)\\1/g.test(part)) {
                return false;
            }
        }
        // If it starts with a number, it's invalid
        if (/^\\d/g.test(part)) {
            return false;
        }
        fonts++;
        return true;
    });
    if (!result) return false;
    return fonts > 0;
}
let genericNames = new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
]);
function genericName(value) {
    return genericNames.has(value);
}
let absoluteSizes = new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
]);
function absoluteSize(value) {
    return absoluteSizes.has(value);
}
let relativeSizes = new Set([
    "larger",
    "smaller"
]);
function relativeSize(value) {
    return relativeSizes.has(value);
}
"
`;

exports[`tailwindcss source code patch patch 3.0.0 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', 'rpx']",
  "plugin": ""use strict";

var _setupTrackingContext = _interopRequireDefault(require("./lib/setupTrackingContext"));
var _setupWatchingContext = _interopRequireDefault(require("./lib/setupWatchingContext"));
var _processTailwindFeatures = _interopRequireDefault(require("./processTailwindFeatures"));
var _sharedState = require("./lib/sharedState");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: 'tailwindcss',
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log('\\n');
      console.time('JIT TOTAL');
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      let setupContext = _sharedState.env.TAILWIND_MODE === 'watch' ? (0, _setupWatchingContext).default(configOrPath) : (0, _setupTrackingContext).default(configOrPath);
      contextRef.value.push((0, _processTailwindFeatures).default(setupContext)(root, result));
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd('JIT TOTAL');
      console.log('\\n');
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = processTailwindFeatures;
var _normalizeTailwindDirectives = _interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
var _expandTailwindAtRules = _interopRequireDefault(require("./lib/expandTailwindAtRules"));
var _expandApplyAtRules = _interopRequireDefault(require("./lib/expandApplyAtRules"));
var _evaluateTailwindFunctions = _interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
var _substituteScreenAtRules = _interopRequireDefault(require("./lib/substituteScreenAtRules"));
var _resolveDefaultsAtRules = _interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
var _collapseAdjacentRules = _interopRequireDefault(require("./lib/collapseAdjacentRules"));
var _collapseDuplicateDeclarations = _interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
var _detectNesting = _interopRequireDefault(require("./lib/detectNesting"));
var _setupContextUtils = require("./lib/setupContextUtils");
var _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let tailwindDirectives = (0, _normalizeTailwindDirectives).default(root);
    let context = setupContext({
      tailwindDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: 'tailwindcss',
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils).createContext(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === '-') {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags).issueFlagNotices(context.tailwindConfig);
    (0, _detectNesting).default(context)(root, result);
    (0, _expandTailwindAtRules).default(context)(root, result);
    (0, _expandApplyAtRules).default(context)(root, result);
    (0, _evaluateTailwindFunctions).default(context)(root, result);
    (0, _substituteScreenAtRules).default(context)(root, result);
    (0, _resolveDefaultsAtRules).default(context)(root, result);
    (0, _collapseAdjacentRules).default(context)(root, result);
    (0, _collapseDuplicateDeclarations).default(context)(root, result);
    return context;
  };
}",
}
`;

exports[`tailwindcss source code patch patch 3.2.3 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', 'rpx']",
  "plugin": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const _setupTrackingContext = /*#__PURE__*/_interopRequireDefault(require("./lib/setupTrackingContext"));
const _processTailwindFeatures = /*#__PURE__*/_interopRequireDefault(require("./processTailwindFeatures"));
const _sharedState = require("./lib/sharedState");
const _findAtConfigPath = require("./lib/findAtConfigPath");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      var ref;
      // Use the path for the \`@config\` directive if it exists, otherwise use the
      // path for the file being processed
      configOrPath = (ref = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && ref !== void 0 ? ref : configOrPath;
      let context = (0, _setupTrackingContext.default)(configOrPath);
      if (root.type === "document") {
        let roots = root.nodes.filter(node => node.type === "root");
        for (const root1 of roots) {
          if (root1.type === "root") {
            contextRef.value.push((0, _processTailwindFeatures.default)(context)(root1, result));
          }
        }
        return;
      }
      contextRef.value.push((0, _processTailwindFeatures.default)(context)(root, result));
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\\n");
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: () => processTailwindFeatures
});
const _normalizeTailwindDirectives = /*#__PURE__*/_interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
const _expandTailwindAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandTailwindAtRules"));
const _expandApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandApplyAtRules"));
const _evaluateTailwindFunctions = /*#__PURE__*/_interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
const _substituteScreenAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/substituteScreenAtRules"));
const _resolveDefaultsAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
const _collapseAdjacentRules = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseAdjacentRules"));
const _collapseDuplicateDeclarations = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
const _partitionApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/partitionApplyAtRules"));
const _detectNesting = /*#__PURE__*/_interopRequireDefault(require("./lib/detectNesting"));
const _setupContextUtils = require("./lib/setupContextUtils");
const _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let {
      tailwindDirectives,
      applyDirectives
    } = (0, _normalizeTailwindDirectives.default)(root);
    (0, _detectNesting.default)()(root, result);
    // Partition apply rules that are found in the css
    // itself.
    (0, _partitionApplyAtRules.default)()(root, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
    (0, _expandTailwindAtRules.default)(context)(root, result);
    // Partition apply rules that are generated by
    // addComponents, addUtilities and so on.
    (0, _partitionApplyAtRules.default)()(root, result);
    (0, _expandApplyAtRules.default)(context)(root, result);
    (0, _evaluateTailwindFunctions.default)(context)(root, result);
    (0, _substituteScreenAtRules.default)(context)(root, result);
    (0, _resolveDefaultsAtRules.default)(context)(root, result);
    (0, _collapseAdjacentRules.default)(context)(root, result);
    (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    return context;
  };
}",
}
`;

exports[`tailwindcss source code patch patch 3.2.4 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', 'rpx']",
  "plugin": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const _setupTrackingContext = /*#__PURE__*/_interopRequireDefault(require("./lib/setupTrackingContext"));
const _processTailwindFeatures = /*#__PURE__*/_interopRequireDefault(require("./processTailwindFeatures"));
const _sharedState = require("./lib/sharedState");
const _findAtConfigPath = require("./lib/findAtConfigPath");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      var ref;
      // Use the path for the \`@config\` directive if it exists, otherwise use the
      // path for the file being processed
      configOrPath = (ref = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && ref !== void 0 ? ref : configOrPath;
      let context = (0, _setupTrackingContext.default)(configOrPath);
      if (root.type === "document") {
        let roots = root.nodes.filter(node => node.type === "root");
        for (const root1 of roots) {
          if (root1.type === "root") {
            contextRef.value.push((0, _processTailwindFeatures.default)(context)(root1, result));
          }
        }
        return;
      }
      contextRef.value.push((0, _processTailwindFeatures.default)(context)(root, result));
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\\n");
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: () => processTailwindFeatures
});
const _normalizeTailwindDirectives = /*#__PURE__*/_interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
const _expandTailwindAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandTailwindAtRules"));
const _expandApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandApplyAtRules"));
const _evaluateTailwindFunctions = /*#__PURE__*/_interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
const _substituteScreenAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/substituteScreenAtRules"));
const _resolveDefaultsAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
const _collapseAdjacentRules = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseAdjacentRules"));
const _collapseDuplicateDeclarations = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
const _partitionApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/partitionApplyAtRules"));
const _detectNesting = /*#__PURE__*/_interopRequireDefault(require("./lib/detectNesting"));
const _setupContextUtils = require("./lib/setupContextUtils");
const _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let {
      tailwindDirectives,
      applyDirectives
    } = (0, _normalizeTailwindDirectives.default)(root);
    (0, _detectNesting.default)()(root, result);
    // Partition apply rules that are found in the css
    // itself.
    (0, _partitionApplyAtRules.default)()(root, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
    (0, _expandTailwindAtRules.default)(context)(root, result);
    // Partition apply rules that are generated by
    // addComponents, addUtilities and so on.
    (0, _partitionApplyAtRules.default)()(root, result);
    (0, _expandApplyAtRules.default)(context)(root, result);
    (0, _evaluateTailwindFunctions.default)(context)(root, result);
    (0, _substituteScreenAtRules.default)(context)(root, result);
    (0, _resolveDefaultsAtRules.default)(context)(root, result);
    (0, _collapseAdjacentRules.default)(context)(root, result);
    (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    return context;
  };
}",
}
`;

exports[`tailwindcss source code patch patch 3.2.6 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vmin', 'vmax', 'vb', 'vi', 'svw', 'svh', 'lvw', 'lvh', 'dvw', 'dvh', 'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax', 'rpx']",
  "plugin": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const _setupTrackingContext = /*#__PURE__*/_interopRequireDefault(require("./lib/setupTrackingContext"));
const _processTailwindFeatures = /*#__PURE__*/_interopRequireDefault(require("./processTailwindFeatures"));
const _sharedState = require("./lib/sharedState");
const _findAtConfigPath = require("./lib/findAtConfigPath");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      var _findAtConfigPath1;
      // Use the path for the \`@config\` directive if it exists, otherwise use the
      // path for the file being processed
      configOrPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : configOrPath;
      let context = (0, _setupTrackingContext.default)(configOrPath);
      if (root.type === "document") {
        let roots = root.nodes.filter(node => node.type === "root");
        for (const root1 of roots) {
          if (root1.type === "root") {
            contextRef.value.push((0, _processTailwindFeatures.default)(context)(root1, result));
          }
        }
        return;
      }
      contextRef.value.push((0, _processTailwindFeatures.default)(context)(root, result));
    }, _sharedState.env.OXIDE && function lightningCssPlugin(_root, result) {
      let postcss = require("postcss");
      let lightningcss = require("lightningcss");
      let browserslist = require("browserslist");
      try {
        let transformed = lightningcss.transform({
          filename: result.opts.from,
          code: Buffer.from(result.root.toString()),
          minify: false,
          sourceMap: !!result.map,
          inputSourceMap: result.map ? result.map.toString() : undefined,
          targets: typeof process !== "undefined" && process.env.JEST_WORKER_ID ? {
            chrome: 106 << 16
          } : lightningcss.browserslistToTargets(browserslist(require("../package.json").browserslist)),
          drafts: {
            nesting: true,
            customMedia: true
          }
        });
        var _result_map;
        result.map = Object.assign((_result_map = result.map) !== null && _result_map !== void 0 ? _result_map : {}, {
          toJSON() {
            return transformed.map.toJSON();
          },
          toString() {
            return transformed.map.toString();
          }
        });
        result.root = postcss.parse(transformed.code.toString("utf8"));
      } catch (err) {
        if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) {
          let lines = err.source.split("\\n");
          err = new Error(["Error formatting using Lightning CSS:", "", ...["\`\`\`css", ...lines.slice(Math.max(err.loc.line - 3, 0), err.loc.line), " ".repeat(err.loc.column - 1) + "^-- " + err.toString(), ...lines.slice(err.loc.line, err.loc.line + 2), "\`\`\`"]].join("\\n"));
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(err, lightningCssPlugin);
        }
        throw err;
      }
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\\n");
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: () => processTailwindFeatures
});
const _normalizeTailwindDirectives = /*#__PURE__*/_interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
const _expandTailwindAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandTailwindAtRules"));
const _expandApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandApplyAtRules"));
const _evaluateTailwindFunctions = /*#__PURE__*/_interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
const _substituteScreenAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/substituteScreenAtRules"));
const _resolveDefaultsAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
const _collapseAdjacentRules = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseAdjacentRules"));
const _collapseDuplicateDeclarations = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
const _partitionApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/partitionApplyAtRules"));
const _detectNesting = /*#__PURE__*/_interopRequireDefault(require("./lib/detectNesting"));
const _setupContextUtils = require("./lib/setupContextUtils");
const _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let {
      tailwindDirectives,
      applyDirectives
    } = (0, _normalizeTailwindDirectives.default)(root);
    (0, _detectNesting.default)()(root, result);
    // Partition apply rules that are found in the css
    // itself.
    (0, _partitionApplyAtRules.default)()(root, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
    (0, _expandTailwindAtRules.default)(context)(root, result);
    // Partition apply rules that are generated by
    // addComponents, addUtilities and so on.
    (0, _partitionApplyAtRules.default)()(root, result);
    (0, _expandApplyAtRules.default)(context)(root, result);
    (0, _evaluateTailwindFunctions.default)(context)(root, result);
    (0, _substituteScreenAtRules.default)(context)(root, result);
    (0, _resolveDefaultsAtRules.default)(context)(root, result);
    (0, _collapseAdjacentRules.default)(context)(root, result);
    (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    return context;
  };
}",
}
`;

exports[`tailwindcss source code patch patch 3.2.7 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vmin', 'vmax', 'vb', 'vi', 'svw', 'svh', 'lvw', 'lvh', 'dvw', 'dvh', 'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax', 'rpx']",
  "plugin": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const _setupTrackingContext = /*#__PURE__*/_interopRequireDefault(require("./lib/setupTrackingContext"));
const _processTailwindFeatures = /*#__PURE__*/_interopRequireDefault(require("./processTailwindFeatures"));
const _sharedState = require("./lib/sharedState");
const _findAtConfigPath = require("./lib/findAtConfigPath");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      var _findAtConfigPath1;
      // Use the path for the \`@config\` directive if it exists, otherwise use the
      // path for the file being processed
      configOrPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : configOrPath;
      let context = (0, _setupTrackingContext.default)(configOrPath);
      if (root.type === "document") {
        let roots = root.nodes.filter(node => node.type === "root");
        for (const root1 of roots) {
          if (root1.type === "root") {
            contextRef.value.push((0, _processTailwindFeatures.default)(context)(root1, result));
          }
        }
        return;
      }
      contextRef.value.push((0, _processTailwindFeatures.default)(context)(root, result));
    }, _sharedState.env.OXIDE && function lightningCssPlugin(_root, result) {
      let postcss = require("postcss");
      let lightningcss = require("lightningcss");
      let browserslist = require("browserslist");
      try {
        let transformed = lightningcss.transform({
          filename: result.opts.from,
          code: Buffer.from(result.root.toString()),
          minify: false,
          sourceMap: !!result.map,
          inputSourceMap: result.map ? result.map.toString() : undefined,
          targets: typeof process !== "undefined" && process.env.JEST_WORKER_ID ? {
            chrome: 106 << 16
          } : lightningcss.browserslistToTargets(browserslist(require("../package.json").browserslist)),
          drafts: {
            nesting: true,
            customMedia: true
          }
        });
        var _result_map;
        result.map = Object.assign((_result_map = result.map) !== null && _result_map !== void 0 ? _result_map : {}, {
          toJSON() {
            return transformed.map.toJSON();
          },
          toString() {
            return transformed.map.toString();
          }
        });
        result.root = postcss.parse(transformed.code.toString("utf8"));
      } catch (err) {
        if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) {
          let lines = err.source.split("\\n");
          err = new Error(["Error formatting using Lightning CSS:", "", ...["\`\`\`css", ...lines.slice(Math.max(err.loc.line - 3, 0), err.loc.line), " ".repeat(err.loc.column - 1) + "^-- " + err.toString(), ...lines.slice(err.loc.line, err.loc.line + 2), "\`\`\`"]].join("\\n"));
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(err, lightningCssPlugin);
        }
        throw err;
      }
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\\n");
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: () => processTailwindFeatures
});
const _normalizeTailwindDirectives = /*#__PURE__*/_interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
const _expandTailwindAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandTailwindAtRules"));
const _expandApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandApplyAtRules"));
const _evaluateTailwindFunctions = /*#__PURE__*/_interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
const _substituteScreenAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/substituteScreenAtRules"));
const _resolveDefaultsAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
const _collapseAdjacentRules = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseAdjacentRules"));
const _collapseDuplicateDeclarations = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
const _partitionApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/partitionApplyAtRules"));
const _detectNesting = /*#__PURE__*/_interopRequireDefault(require("./lib/detectNesting"));
const _setupContextUtils = require("./lib/setupContextUtils");
const _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let {
      tailwindDirectives,
      applyDirectives
    } = (0, _normalizeTailwindDirectives.default)(root);
    (0, _detectNesting.default)()(root, result);
    // Partition apply rules that are found in the css
    // itself.
    (0, _partitionApplyAtRules.default)()(root, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
    (0, _expandTailwindAtRules.default)(context)(root, result);
    // Partition apply rules that are generated by
    // addComponents, addUtilities and so on.
    (0, _partitionApplyAtRules.default)()(root, result);
    (0, _expandApplyAtRules.default)(context)(root, result);
    (0, _evaluateTailwindFunctions.default)(context)(root, result);
    (0, _substituteScreenAtRules.default)(context)(root, result);
    (0, _resolveDefaultsAtRules.default)(context)(root, result);
    (0, _collapseAdjacentRules.default)(context)(root, result);
    (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    return context;
  };
}",
}
`;

exports[`tailwindcss source code patch patch lts 1`] = `
{
  "dataTypes": "['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vmin', 'vmax', 'vb', 'vi', 'svw', 'svh', 'lvw', 'lvh', 'dvw', 'dvh', 'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax', 'rpx']",
  "plugin": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const _setupTrackingContext = /*#__PURE__*/_interopRequireDefault(require("./lib/setupTrackingContext"));
const _processTailwindFeatures = /*#__PURE__*/_interopRequireDefault(require("./processTailwindFeatures"));
const _sharedState = require("./lib/sharedState");
const _findAtConfigPath = require("./lib/findAtConfigPath");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const contextRef = {
  value: []
};
module.exports = function tailwindcss(configOrPath) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [_sharedState.env.DEBUG && function (root) {
      console.log("\\n");
      console.time("JIT TOTAL");
      return root;
    }, function (root, result) {
      contextRef.value.length = 0;
      var _findAtConfigPath1;
      // Use the path for the \`@config\` directive if it exists, otherwise use the
      // path for the file being processed
      configOrPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : configOrPath;
      let context = (0, _setupTrackingContext.default)(configOrPath);
      if (root.type === "document") {
        let roots = root.nodes.filter(node => node.type === "root");
        for (const root1 of roots) {
          if (root1.type === "root") {
            contextRef.value.push((0, _processTailwindFeatures.default)(context)(root1, result));
          }
        }
        return;
      }
      contextRef.value.push((0, _processTailwindFeatures.default)(context)(root, result));
    }, _sharedState.env.OXIDE && function lightningCssPlugin(_root, result) {
      let postcss = require("postcss");
      let lightningcss = require("lightningcss");
      let browserslist = require("browserslist");
      try {
        let transformed = lightningcss.transform({
          filename: result.opts.from,
          code: Buffer.from(result.root.toString()),
          minify: false,
          sourceMap: !!result.map,
          inputSourceMap: result.map ? result.map.toString() : undefined,
          targets: typeof process !== "undefined" && process.env.JEST_WORKER_ID ? {
            chrome: 106 << 16
          } : lightningcss.browserslistToTargets(browserslist(require("../package.json").browserslist)),
          drafts: {
            nesting: true,
            customMedia: true
          }
        });
        var _result_map;
        result.map = Object.assign((_result_map = result.map) !== null && _result_map !== void 0 ? _result_map : {}, {
          toJSON() {
            return transformed.map.toJSON();
          },
          toString() {
            return transformed.map.toString();
          }
        });
        result.root = postcss.parse(transformed.code.toString("utf8"));
      } catch (err) {
        if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) {
          let lines = err.source.split("\\n");
          err = new Error(["Error formatting using Lightning CSS:", "", ...["\`\`\`css", ...lines.slice(Math.max(err.loc.line - 3, 0), err.loc.line), " ".repeat(err.loc.column - 1) + "^-- " + err.toString(), ...lines.slice(err.loc.line, err.loc.line + 2), "\`\`\`"]].join("\\n"));
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(err, lightningCssPlugin);
        }
        throw err;
      }
    }, _sharedState.env.DEBUG && function (root) {
      console.timeEnd("JIT TOTAL");
      console.log("\\n");
      return root;
    }].filter(Boolean)
  };
};
module.exports.postcss = true;
module.exports.contextRef = contextRef;",
  "processTailwindFeatures": ""use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: () => processTailwindFeatures
});
const _normalizeTailwindDirectives = /*#__PURE__*/_interopRequireDefault(require("./lib/normalizeTailwindDirectives"));
const _expandTailwindAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandTailwindAtRules"));
const _expandApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/expandApplyAtRules"));
const _evaluateTailwindFunctions = /*#__PURE__*/_interopRequireDefault(require("./lib/evaluateTailwindFunctions"));
const _substituteScreenAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/substituteScreenAtRules"));
const _resolveDefaultsAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/resolveDefaultsAtRules"));
const _collapseAdjacentRules = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseAdjacentRules"));
const _collapseDuplicateDeclarations = /*#__PURE__*/_interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));
const _partitionApplyAtRules = /*#__PURE__*/_interopRequireDefault(require("./lib/partitionApplyAtRules"));
const _detectNesting = /*#__PURE__*/_interopRequireDefault(require("./lib/detectNesting"));
const _setupContextUtils = require("./lib/setupContextUtils");
const _featureFlags = require("./featureFlags");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function processTailwindFeatures(setupContext) {
  return function (root, result) {
    let {
      tailwindDirectives,
      applyDirectives
    } = (0, _normalizeTailwindDirectives.default)(root);
    (0, _detectNesting.default)()(root, result);
    // Partition apply rules that are found in the css
    // itself.
    (0, _partitionApplyAtRules.default)()(root, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
      }
    })(root, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    }
    (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
    (0, _expandTailwindAtRules.default)(context)(root, result);
    // Partition apply rules that are generated by
    // addComponents, addUtilities and so on.
    (0, _partitionApplyAtRules.default)()(root, result);
    (0, _expandApplyAtRules.default)(context)(root, result);
    (0, _evaluateTailwindFunctions.default)(context)(root, result);
    (0, _substituteScreenAtRules.default)(context)(root, result);
    (0, _resolveDefaultsAtRules.default)(context)(root, result);
    (0, _collapseAdjacentRules.default)(context)(root, result);
    (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    return context;
  };
}",
}
`;
