// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`rollup build lib build 1`] = `
[
  {
    "code": "'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var options = require('./options-9d17b73a.js');
var postcss = require('./plugin-27708d63.js');
require('micromatch');
require('@babel/generator');
require('@babel/parser');
require('@babel/traverse');
require('@babel/types');
require('postcss');
require('@csstools/postcss-is-pseudo-class');
require('path');
require('fs');
require('semver');
require('tailwindcss-patch');
require('postcss-selector-parser');

class UnifiedWebpackPluginV5 {
    constructor(options$1 = {}) {
        if (typeof options$1.customReplaceDictionary === 'undefined') {
            options$1.customReplaceDictionary = 'simple';
        }
        this.options = options.getOptions(options$1, ['style', 'patch', 'templete', 'js']);
        this.appType = this.options.appType;
    }
    apply(compiler) {
        const { mainCssChunkMatcher, disabled, onLoad, onUpdate, onEnd, onStart, styleHandler, patch, templeteHandler, jsHandler } = this.options;
        if (disabled) {
            return;
        }
        patch === null || patch === void 0 ? void 0 : patch();
        const Compilation = compiler.webpack.Compilation;
        const { ConcatSource } = compiler.webpack.sources;
        const twPatcher = options.createTailwindcssPatcher();
        function getClassSet() {
            let set = twPatcher.getClassSet();
            if (!set.size) {
                const cacheSet = twPatcher.getCache();
                if (cacheSet && cacheSet.size) {
                    set = cacheSet;
                }
            }
            return set;
        }
        onLoad();
        compiler.hooks.compilation.tap(postcss.pluginName, (compilation) => {
            compilation.hooks.processAssets.tap({
                name: postcss.pluginName,
                stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
            }, (assets) => {
                onStart();
                const entries = Object.entries(assets);
                const groupedEntries = options.getGroupedEntries(entries, this.options);
                if (Array.isArray(groupedEntries.html)) {
                    for (let i = 0; i < groupedEntries.html.length; i++) {
                        const [file, originalSource] = groupedEntries.html[i];
                        const rawSource = originalSource.source().toString();
                        const wxml = templeteHandler(rawSource);
                        const source = new ConcatSource(wxml);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, wxml);
                    }
                }
                if (Array.isArray(groupedEntries.js)) {
                    const set = getClassSet();
                    for (let i = 0; i < groupedEntries.js.length; i++) {
                        const [file, originalSource] = groupedEntries.js[i];
                        const rawSource = originalSource.source().toString();
                        const { code } = jsHandler(rawSource, set);
                        const source = new ConcatSource(code);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, code);
                    }
                }
                if (Array.isArray(groupedEntries.css)) {
                    for (let i = 0; i < groupedEntries.css.length; i++) {
                        const [file, originalSource] = groupedEntries.css[i];
                        const rawSource = originalSource.source().toString();
                        const css = styleHandler(rawSource, {
                            isMainChunk: mainCssChunkMatcher(file, this.appType)
                        });
                        const source = new ConcatSource(css);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, css);
                    }
                }
                onEnd();
            });
        });
    }
}
UnifiedWebpackPluginV5.NS = postcss.NS;

exports.UnifiedWebpackPluginV5 = UnifiedWebpackPluginV5;
",
    "dynamicImports": [],
    "exports": [
      "UnifiedWebpackPluginV5",
    ],
    "fileName": "index.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@babel/generator": [],
      "@babel/parser": [],
      "@babel/traverse": [],
      "@babel/types": [],
      "@csstools/postcss-is-pseudo-class": [],
      "fs": [],
      "micromatch": [],
      "options-9d17b73a.js": [
        "getOptions",
        "createTailwindcssPatcher",
        "getGroupedEntries",
      ],
      "path": [],
      "plugin-27708d63.js": [
        "pluginName",
        "NS",
      ],
      "postcss": [],
      "postcss-selector-parser": [],
      "semver": [],
      "tailwindcss-patch": [],
    },
    "imports": [
      "options-9d17b73a.js",
      "plugin-27708d63.js",
      "micromatch",
      "@babel/generator",
      "@babel/parser",
      "@babel/traverse",
      "@babel/types",
      "postcss",
      "@csstools/postcss-is-pseudo-class",
      "path",
      "fs",
      "semver",
      "tailwindcss-patch",
      "postcss-selector-parser",
    ],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "index",
    "referencedFiles": [],
    "type": "chunk",
  },
  {
    "code": "'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var options = require('./options-9d17b73a.js');
var stream = require('stream');
require('micromatch');
require('@babel/generator');
require('@babel/parser');
require('@babel/traverse');
require('./plugin-27708d63.js');
require('postcss-selector-parser');
require('postcss');
require('@csstools/postcss-is-pseudo-class');
require('@babel/types');
require('path');
require('fs');
require('semver');
require('tailwindcss-patch');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var stream__default = /*#__PURE__*/_interopDefaultCompat(stream);

const Transform = stream__default["default"].Transform;
function createPlugins(options$1 = {}) {
    if (typeof options$1.customReplaceDictionary === 'undefined') {
        options$1.customReplaceDictionary = 'simple';
    }
    const opts = options.getOptions(options$1, ['patch', 'style', 'templete', 'js']);
    const { templeteHandler, styleHandler, patch, jsHandler } = opts;
    let set = new Set();
    patch === null || patch === void 0 ? void 0 : patch();
    const twPatcher = options.createTailwindcssPatcher();
    function transformWxss() {
        const transformStream = new Transform({ objectMode: true });
        transformStream._transform = function (file, encoding, callback) {
            set = twPatcher.getClassSet();
            const error = null;
            if (file.contents) {
                const code = styleHandler(file.contents.toString(), {
                    isMainChunk: true
                });
                file.contents = Buffer.from(code);
            }
            callback(error, file);
        };
        return transformStream;
    }
    function transformJs() {
        const transformStream = new Transform({ objectMode: true });
        transformStream._transform = function (file, encoding, callback) {
            const error = null;
            if (file.contents) {
                const { code } = jsHandler(file.contents.toString(), set);
                file.contents = Buffer.from(code);
            }
            callback(error, file);
        };
        return transformStream;
    }
    function transformWxml() {
        const transformStream = new Transform({ objectMode: true });
        transformStream._transform = function (file, encoding, callback) {
            const error = null;
            if (file.contents) {
                const code = templeteHandler(file.contents.toString());
                file.contents = Buffer.from(code);
            }
            callback(error, file);
        };
        return transformStream;
    }
    return {
        transformWxss,
        transformWxml,
        transformJs
    };
}

exports.createPlugins = createPlugins;
",
    "dynamicImports": [],
    "exports": [
      "createPlugins",
    ],
    "fileName": "gulp.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@babel/generator": [],
      "@babel/parser": [],
      "@babel/traverse": [],
      "@babel/types": [],
      "@csstools/postcss-is-pseudo-class": [],
      "fs": [],
      "micromatch": [],
      "options-9d17b73a.js": [
        "getOptions",
        "createTailwindcssPatcher",
      ],
      "path": [],
      "plugin-27708d63.js": [],
      "postcss": [],
      "postcss-selector-parser": [],
      "semver": [],
      "stream": [
        "default",
      ],
      "tailwindcss-patch": [],
    },
    "imports": [
      "options-9d17b73a.js",
      "stream",
      "micromatch",
      "@babel/generator",
      "@babel/parser",
      "@babel/traverse",
      "plugin-27708d63.js",
      "postcss-selector-parser",
      "postcss",
      "@csstools/postcss-is-pseudo-class",
      "@babel/types",
      "path",
      "fs",
      "semver",
      "tailwindcss-patch",
    ],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "gulp",
    "referencedFiles": [],
    "type": "chunk",
  },
  {
    "code": "'use strict';

var options = require('./options-9d17b73a.js');
require('micromatch');
require('@babel/generator');
require('@babel/parser');
require('@babel/traverse');
require('./plugin-27708d63.js');
require('postcss-selector-parser');
require('postcss');
require('@csstools/postcss-is-pseudo-class');
require('@babel/types');
require('path');
require('fs');
require('semver');
require('tailwindcss-patch');

const args = process.argv.slice(2);
if (args[0] === 'patch') {
    const options$1 = options.getOptions();
    const patch = options.createPatch(options$1.supportCustomLengthUnitsPatch);
    patch();
}
",
    "dynamicImports": [],
    "exports": [],
    "fileName": "cli.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@babel/generator": [],
      "@babel/parser": [],
      "@babel/traverse": [],
      "@babel/types": [],
      "@csstools/postcss-is-pseudo-class": [],
      "fs": [],
      "micromatch": [],
      "options-9d17b73a.js": [
        "getOptions",
        "createPatch",
      ],
      "path": [],
      "plugin-27708d63.js": [],
      "postcss": [],
      "postcss-selector-parser": [],
      "semver": [],
      "tailwindcss-patch": [],
    },
    "imports": [
      "options-9d17b73a.js",
      "micromatch",
      "@babel/generator",
      "@babel/parser",
      "@babel/traverse",
      "plugin-27708d63.js",
      "postcss-selector-parser",
      "postcss",
      "@csstools/postcss-is-pseudo-class",
      "@babel/types",
      "path",
      "fs",
      "semver",
      "tailwindcss-patch",
    ],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "cli",
    "referencedFiles": [],
    "type": "chunk",
  },
  {
    "code": "'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var postcss = require('./plugin-27708d63.js');
var postcssIsPseudoClass = require('@csstools/postcss-is-pseudo-class');
require('postcss-selector-parser');
require('postcss');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var postcssIsPseudoClass__default = /*#__PURE__*/_interopDefaultCompat(postcssIsPseudoClass);



exports.postcssWeappTailwindcss = postcss.postcssWeappTailwindcss;
Object.defineProperty(exports, 'postcssIsPseudoClass', {
	enumerable: true,
	get: function () { return postcssIsPseudoClass__default["default"]; }
});
",
    "dynamicImports": [],
    "exports": [
      "postcssIsPseudoClass",
      "postcssWeappTailwindcss",
    ],
    "fileName": "postcss.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@csstools/postcss-is-pseudo-class": [
        "default",
      ],
      "plugin-27708d63.js": [
        "postcssWeappTailwindcss",
      ],
      "postcss": [],
      "postcss-selector-parser": [],
    },
    "imports": [
      "plugin-27708d63.js",
      "@csstools/postcss-is-pseudo-class",
      "postcss-selector-parser",
      "postcss",
    ],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "postcss",
    "referencedFiles": [],
    "type": "chunk",
  },
  {
    "code": "'use strict';

var micromatch = require('micromatch');
var generate = require('@babel/generator');
var parser = require('@babel/parser');
var traverse = require('@babel/traverse');
var postcss = require('./plugin-27708d63.js');
var t = require('@babel/types');
var postcss$1 = require('postcss');
var postcssIsPseudoClass = require('@csstools/postcss-is-pseudo-class');
var path = require('path');
var fs = require('fs');
var semver = require('semver');
var tailwindcssPatch = require('tailwindcss-patch');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var generate__default = /*#__PURE__*/_interopDefaultCompat(generate);
var traverse__default = /*#__PURE__*/_interopDefaultCompat(traverse);
var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);
var postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss$1);
var postcssIsPseudoClass__default = /*#__PURE__*/_interopDefaultCompat(postcssIsPseudoClass);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? \`\${namespace}.\` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

function isRegexp(value) {
    return Object.prototype.toString.call(value) === '[object RegExp]';
}
function isMap(value) {
    return Object.prototype.toString.call(value) === '[object Map]';
}
const noop = () => { };
function groupBy(arr, cb) {
    if (!Array.isArray(arr)) {
        throw new Error('expected an array for first argument');
    }
    if (typeof cb !== 'function') {
        throw new Error('expected a function for second argument');
    }
    const result = {};
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const bucketCategory = cb(item);
        const bucket = result[bucketCategory];
        if (!Array.isArray(bucket)) {
            result[bucketCategory] = [item];
        }
        else {
            result[bucketCategory].push(item);
        }
    }
    return result;
}
function getGroupedEntries(entries, options) {
    const { cssMatcher, htmlMatcher, jsMatcher } = options;
    const groupedEntries = groupBy(entries, ([file]) => {
        if (cssMatcher(file)) {
            return 'css';
        }
        else if (htmlMatcher(file)) {
            return 'html';
        }
        else if (jsMatcher(file)) {
            return 'js';
        }
        else {
            return 'other';
        }
    });
    return groupedEntries;
}

function replaceWxml(original, options = {
    keepEOL: false,
    escapeMap: postcss.SimpleMappingChars2String
}) {
    if (typeof options === 'boolean') {
        options = {
            keepEOL: options
        };
    }
    let res = original;
    if (!options.keepEOL) {
        res = res
            .replace(/[\\r\\n]+/g, '');
    }
    res = postcss.escape(res, {
        map: options.escapeMap
    });
    return res;
}

function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    }
    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');
}
const templateClassExactRegexp = /(?:(?<=^|\\s)(?:hover-)?class)=(?:["']\\W+\\s*(?:\\w+)\\()?["']([^"]+)['"]/gs;
const tagWithEitherClassAndHoverClassRegexp = /<(?:[a-z][-a-z]*[a-z]*)\\s+[^>]*?(?:(?:hover-)?class="(?:[^"]*)")[^>]*?\\/?>/g;
function handleRegexp(reg) {
    return \`(?:\${reg.source})\`;
}
function getSourceString(input) {
    let result;
    if (typeof input === 'string') {
        result = input;
    }
    else if (isRegexp(input)) {
        result = input.source;
    }
    else {
        result = input.toString();
    }
    return result;
}
function makePattern(arr) {
    let pattern = '';
    if (Array.isArray(arr)) {
        pattern = arr
            .reduce((acc, cur) => {
            if (typeof cur === 'string') {
                acc.push(cur);
            }
            else if (isRegexp(cur)) {
                acc.push(handleRegexp(cur));
            }
            return acc;
        }, [])
            .join('|');
    }
    else if (typeof arr === 'string') {
        pattern = arr;
    }
    else if (isRegexp(arr)) {
        pattern = handleRegexp(arr);
    }
    return pattern;
}
function createTempleteHandlerMatchRegexp(tag, attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\\\s)' : '';
    const pattern = makePattern(attrs);
    let tagPattern = getSourceString(tag);
    if (tagPattern === '*') {
        tagPattern = '[a-z][-a-z]*[a-z]*';
    }
    const source = \`<(\${tagPattern})\\\\s+[^>]*?(?:\${prefix}(\${pattern})="(?:[^"]*)")[^>]*?\\\\/?>\`;
    return new RegExp(source, 'g');
}
function createTemplateClassRegexp(attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\\\s)' : '';
    const pattern = makePattern(attrs);
    const source = \`(?:\${prefix}\${pattern})=(?:["']\\\\W+\\\\s*(?:\\\\w+)\\\\()?["']([^"]+)['"]\`;
    return new RegExp(source, 'gs');
}
function makeCustomAttributes(entries) {
    if (Array.isArray(entries)) {
        return entries.map(([k, v]) => {
            return {
                tagRegexp: createTempleteHandlerMatchRegexp(k, v),
                attrRegexp: createTemplateClassRegexp(v),
                tag: getSourceString(k),
                attrs: v
            };
        });
    }
}
const variableRegExp = /{{(.*?)}}/gs;
function variableMatch(original) {
    return variableRegExp.exec(original);
}

function generateCode(match, options = {}) {
    const ast = parser.parseExpression(match);
    traverse__default["default"](ast, {
        StringLiteral(path) {
            var _a;
            if (t__namespace.isMemberExpression(path.parent)) {
                return;
            }
            if (t__namespace.isBinaryExpression(path.parent)) {
                if (t__namespace.isConditionalExpression((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent)) {
                    return;
                }
            }
            path.node.value = replaceWxml(path.node.value, options);
        },
        noScope: true
    });
    const { code } = generate__default["default"](ast, {
        compact: true,
        minified: true,
        jsescOption: {
            quotes: 'single',
            minimal: true
        }
    });
    return code;
}
function extractSource(original) {
    let match = variableMatch(original);
    const sources = [];
    while (match !== null) {
        const start = match.index;
        const end = variableRegExp.lastIndex;
        sources.push({
            start,
            end,
            raw: match[1],
            prevConcatenated: !/\\s/.test(original[start - 1]),
            nextConcatenated: !/\\s/.test(original[end])
        });
        match = variableMatch(original);
    }
    return sources;
}
function templeteReplacer(original, options = {}) {
    const sources = extractSource(original);
    if (sources.length) {
        const resultArray = [];
        let p = 0;
        for (let i = 0; i < sources.length; i++) {
            const m = sources[i];
            const before = original.slice(p, m.start);
            resultArray.push(replaceWxml(before, {
                keepEOL: true,
                escapeMap: options.escapeMap
            }));
            p = m.start;
            if (m.raw.trim().length) {
                const code = generateCode(m.raw, options);
                const source = \`{{\${code}}}\`;
                m.source = source;
            }
            else {
                m.source = '';
            }
            resultArray.push(m.source);
            p = m.end;
            if (i === sources.length - 1) {
                const after = original.slice(m.end);
                resultArray.push(replaceWxml(after, {
                    keepEOL: true,
                    escapeMap: options.escapeMap
                }));
            }
        }
        return resultArray
            .filter((x) => x)
            .join('')
            .trim();
    }
    else {
        return replaceWxml(original, {
            keepEOL: false,
            escapeMap: options.escapeMap
        });
    }
}
function templeteHandler(rawSource, options = {}) {
    return rawSource.replace(tagWithEitherClassAndHoverClassRegexp, (m0) => {
        return m0.replace(templateClassExactRegexp, (m1, className) => {
            return m1.replace(className, templeteReplacer(className, options));
        });
    });
}
function customTempleteHandler(rawSource, options = {}) {
    let source = templeteHandler(rawSource, options);
    const regexps = makeCustomAttributes(options.customAttributesEntities);
    if (regexps) {
        if (Array.isArray(regexps)) {
            for (let i = 0; i < regexps.length; i++) {
                const regexp = regexps[i];
                source = source.replace(regexp.tagRegexp, (m0) => {
                    return m0.replace(regexp.attrRegexp, (m1, className) => {
                        return m1.replace(className, templeteReplacer(className, options));
                    });
                });
            }
        }
        return source;
    }
    else {
        return source;
    }
}
function createTempleteHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTempleteHandler(rawSource, defu(opt, options));
    };
}

function styleHandler(rawSource, options) {
    return postcss__default["default"]([postcss.postcssWeappTailwindcss(options), postcssIsPseudoClass__default["default"]()]).process(rawSource).css;
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defu(opt, options));
    };
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (let i = 0; i < entries.length; i++) {
            const [prop, value] = entries[i];
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString()
                });
            }
        }
    }
    return () => {
        return result;
    };
};

function findAstNode(content, options) {
    const DOPTS = options.dangerousOptions;
    const ast = parser.parse(content);
    let arrayRef;
    let changed = false;
    traverse__default["default"](ast, {
        Identifier(path) {
            if (path.node.name === DOPTS.variableName) {
                if (t__namespace.isVariableDeclarator(path.parent)) {
                    if (t__namespace.isArrayExpression(path.parent.init)) {
                        arrayRef = path.parent.init;
                        const set = new Set(path.parent.init.elements.map((x) => x.value));
                        for (let i = 0; i < options.units.length; i++) {
                            const unit = options.units[i];
                            if (!set.has(unit)) {
                                path.parent.init.elements = path.parent.init.elements.map((x) => {
                                    if (t__namespace.isStringLiteral(x)) {
                                        return {
                                            type: x === null || x === void 0 ? void 0 : x.type,
                                            value: x === null || x === void 0 ? void 0 : x.value
                                        };
                                    }
                                    return x;
                                });
                                path.parent.init.elements.push({
                                    type: 'StringLiteral',
                                    value: unit
                                });
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    });
    return {
        arrayRef,
        changed
    };
}

function getInstalledPkgJsonPath(options) {
    const dangerousOptions = options.dangerousOptions;
    try {
        const tmpJsonPath = tailwindcssPatch.requireResolve(\`\${dangerousOptions.packageName}/package.json\`, {
            paths: options.paths,
            basedir: options.basedir
        });
        return tmpJsonPath;
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.warn('没有找到\`tailwindcss\`包，请确认是否安装。想要禁用打上rpx支持patch或者非\`tailwindcss\`框架，你可以设置 \`supportCustomLengthUnitsPatch\` 为 false');
        }
    }
}
function createPatch(options) {
    if (options === false) {
        return noop;
    }
    return () => {
        try {
            return internalPatch(getInstalledPkgJsonPath(options), options);
        }
        catch (error) {
            console.warn(\`patch tailwindcss failed:\` + error.message);
        }
    };
}
function monkeyPatchForSupportingCustomUnit(rootDir, options) {
    var _a;
    const { dangerousOptions } = options;
    const DOPTS = dangerousOptions;
    const dataTypesFilePath = path__default["default"].resolve(rootDir, DOPTS.lengthUnitsFilePath);
    const dataTypesFileContent = fs__default["default"].readFileSync(dataTypesFilePath, {
        encoding: 'utf-8'
    });
    const { arrayRef, changed } = findAstNode(dataTypesFileContent, options);
    if (arrayRef && changed) {
        const { code } = generate__default["default"](arrayRef, {
            jsescOption: {
                quotes: 'single'
            }
        });
        if (arrayRef.start && arrayRef.end) {
            const prev = dataTypesFileContent.slice(0, arrayRef.start);
            const next = dataTypesFileContent.slice(arrayRef.end);
            const newCode = prev + code + next;
            if (DOPTS.overwrite) {
                fs__default["default"].writeFileSync((_a = DOPTS.destPath) !== null && _a !== void 0 ? _a : dataTypesFilePath, newCode, {
                    encoding: 'utf-8'
                });
                console.log('patch tailwindcss for custom length unit successfully!');
            }
        }
        return code;
    }
}
function internalPatch(pkgJsonPath, options, overwrite = true) {
    if (pkgJsonPath) {
        const pkgJson = require(pkgJsonPath);
        const dangerousOptions = options.dangerousOptions;
        if (semver.gte(pkgJson.version, dangerousOptions.gteVersion)) {
            const rootDir = path__default["default"].dirname(pkgJsonPath);
            const dataTypes = monkeyPatchForSupportingCustomUnit(rootDir, options);
            const result = tailwindcssPatch.monkeyPatchForExposingContext(rootDir, {
                overwrite
            });
            return Object.assign(Object.assign({}, result), { dataTypes });
        }
    }
}
function createTailwindcssPatcher() {
    return new tailwindcssPatch.TailwindcssPatcher({
        cache: true
    });
}

const validateFilterRE = /[\\w\\u00A0-\\uFFFF-_:%-?]/;
function isValidSelector(selector = '') {
    return validateFilterRE.test(selector);
}
const splitCode = (code) => {
    return code.split(/[\\s]+/).filter(isValidSelector);
};

const isProd = () => process.env.NODE_ENV === 'production';

function handleValue(str, node, options) {
    const set = options.classNameSet;
    const escapeMap = options.escapeMap;
    const arr = splitCode(str);
    let rawStr = str;
    for (let i = 0; i < arr.length; i++) {
        const v = arr[i];
        if (set.has(v)) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                rawStr = rawStr.replace(new RegExp(escapeStringRegexp(v), 'g'), replaceWxml(v, {
                    escapeMap
                }));
            }
        }
    }
    return rawStr;
}
function jsHandler(rawSource, options) {
    var _a;
    const ast = parser.parse(rawSource, {
        sourceType: 'unambiguous'
    });
    const topt = {
        StringLiteral: {
            enter(p) {
                const n = p.node;
                n.value = handleValue(n.value, n, options);
            }
        },
        TemplateElement: {
            enter(p) {
                const n = p.node;
                n.value.raw = handleValue(n.value.raw, n, options);
            }
        },
        CallExpression: {
            enter(p) {
                const n = p.node;
                if (t__namespace.isIdentifier(n.callee) && n.callee.name === 'eval') {
                    if (t__namespace.isStringLiteral(n.arguments[0])) {
                        const res = jsHandler(n.arguments[0].value, options);
                        if (res.code) {
                            n.arguments[0].value = res.code;
                        }
                    }
                }
            }
        },
        noScope: true
    };
    traverse__default["default"](ast, topt);
    return generate__default["default"](ast, {
        minified: (_a = options.minifiedJs) !== null && _a !== void 0 ? _a : isProd()
    });
}
function createjsHandler(options) {
    return (rawSource, set) => {
        return jsHandler(rawSource, {
            classNameSet: set,
            minifiedJs: options.minifiedJs,
            escapeMap: options.escapeMap
        });
    };
}

const defaultOptions = {
    cssMatcher: (file) => /.+\\.(?:wx|ac|jx|tt|q|c)ss$/.test(file),
    htmlMatcher: (file) => /.+\\.(?:(?:(?:wx|ax|jx|ks|tt|q)ml)|swan)$/.test(file),
    jsMatcher: (file) => {
        if (file.includes('node_modules')) {
            return false;
        }
        return /.+\\.[cm]?[jt]sx?$/.test(file);
    },
    mainCssChunkMatcher: (file, appType) => {
        switch (appType) {
            case 'uni-app': {
                return /^common\\/main/.test(file);
            }
            case 'uni-app-vite': {
                return /^app/.test(file) || /^common\\/main/.test(file);
            }
            case 'mpx': {
                return /^app/.test(file);
            }
            case 'taro': {
                return /^app/.test(file);
            }
            case 'remax': {
                return /^app/.test(file);
            }
            case 'rax': {
                return /^bundle/.test(file);
            }
            case 'native': {
                return /^app/.test(file);
            }
            case 'kbone': {
                return /^(?:common\\/)?miniprogram-app/.test(file);
            }
            default: {
                return true;
            }
        }
    },
    cssPreflight: {
        'box-sizing': 'border-box',
        'border-width': '0',
        'border-style': 'solid',
        'border-color': 'currentColor'
    },
    cssPreflightRange: 'view',
    replaceUniversalSelectorWith: 'view',
    disabled: false,
    customRuleCallback: noop,
    onLoad: noop,
    onStart: noop,
    onEnd: noop,
    onUpdate: noop,
    customAttributes: {},
    customReplaceDictionary: postcss.SimpleMappingChars2String,
    supportCustomLengthUnitsPatch: {
        units: ['rpx'],
        dangerousOptions: {
            gteVersion: '3.0.0',
            lengthUnitsFilePath: 'lib/util/dataTypes.js',
            packageName: 'tailwindcss',
            variableName: 'lengthUnits',
            overwrite: true
        }
    },
    appType: undefined
};

function createGlobMatcher(pattern) {
    return function (file) {
        return micromatch.isMatch(file, pattern);
    };
}
function normalizeMatcher(options, key) {
    if (typeof options[key] === 'string' || Array.isArray(options[key])) {
        options[key] = createGlobMatcher(options[key]);
    }
}
function getOptions(options = {}, modules = ['style', 'templete', 'patch', 'js']) {
    const registerModules = modules.reduce((acc, cur) => {
        if (acc[cur] !== undefined) {
            acc[cur] = true;
        }
        return acc;
    }, {
        templete: false,
        style: false,
        patch: false,
        js: false
    });
    if (options.supportCustomLengthUnitsPatch === true) {
        options.supportCustomLengthUnitsPatch = undefined;
    }
    if (options.customReplaceDictionary === 'simple') {
        options.customReplaceDictionary = postcss.SimpleMappingChars2String;
    }
    else if (options.customReplaceDictionary === 'complex') {
        options.customReplaceDictionary = postcss.MappingChars2String;
    }
    normalizeMatcher(options, 'cssMatcher');
    normalizeMatcher(options, 'htmlMatcher');
    normalizeMatcher(options, 'jsMatcher');
    normalizeMatcher(options, 'mainCssChunkMatcher');
    const result = defu(options, defaultOptions, {
        minifiedJs: isProd()
    });
    const { cssPreflight, customRuleCallback, cssPreflightRange, replaceUniversalSelectorWith, customAttributes, customReplaceDictionary, supportCustomLengthUnitsPatch } = result;
    result.escapeMap = customReplaceDictionary;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    let customAttributesEntities;
    if (isMap(options.customAttributes)) {
        customAttributesEntities = Array.from(options.customAttributes.entries());
    }
    else {
        customAttributesEntities = Object.entries(customAttributes);
    }
    if (registerModules.templete) {
        result.templeteHandler = createTempleteHandler({
            customAttributesEntities,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.style) {
        result.styleHandler = createStyleHandler({
            cssInjectPreflight,
            customRuleCallback,
            cssPreflightRange,
            replaceUniversalSelectorWith,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.js) {
        result.jsHandler = createjsHandler({
            minifiedJs: result.minifiedJs,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.patch) {
        result.patch = createPatch(supportCustomLengthUnitsPatch);
    }
    return result;
}

exports.createPatch = createPatch;
exports.createTailwindcssPatcher = createTailwindcssPatcher;
exports.getGroupedEntries = getGroupedEntries;
exports.getOptions = getOptions;
",
    "dynamicImports": [],
    "exports": [
      "createPatch",
      "createTailwindcssPatcher",
      "getGroupedEntries",
      "getOptions",
    ],
    "fileName": "options-9d17b73a.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@babel/generator": [
        "default",
      ],
      "@babel/parser": [
        "parseExpression",
        "parse",
      ],
      "@babel/traverse": [
        "default",
      ],
      "@babel/types": [
        "*",
      ],
      "@csstools/postcss-is-pseudo-class": [
        "default",
      ],
      "fs": [
        "default",
      ],
      "micromatch": [
        "isMatch",
      ],
      "path": [
        "default",
      ],
      "plugin-27708d63.js": [
        "escape",
        "SimpleMappingChars2String",
        "postcssWeappTailwindcss",
        "MappingChars2String",
      ],
      "postcss": [
        "default",
      ],
      "semver": [
        "gte",
      ],
      "tailwindcss-patch": [
        "monkeyPatchForExposingContext",
        "requireResolve",
        "TailwindcssPatcher",
      ],
    },
    "imports": [
      "micromatch",
      "@babel/generator",
      "@babel/parser",
      "@babel/traverse",
      "plugin-27708d63.js",
      "@babel/types",
      "postcss",
      "@csstools/postcss-is-pseudo-class",
      "path",
      "fs",
      "semver",
      "tailwindcss-patch",
    ],
    "isDynamicEntry": false,
    "isEntry": false,
    "isImplicitEntry": false,
    "map": null,
    "name": "options",
    "referencedFiles": [],
    "type": "chunk",
  },
  {
    "code": "'use strict';

var selectorParser = require('postcss-selector-parser');
var postcss = require('postcss');
require('@csstools/postcss-is-pseudo-class');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var selectorParser__default = /*#__PURE__*/_interopDefaultCompat(selectorParser);

const MappingChars2String = {
    '[': '_bl_',
    ']': '_br_',
    '(': '_pl_',
    ')': '_qr_',
    '#': '_h_',
    '!': '_i_',
    '/': '_s_',
    '\\\\': '_bs_',
    '.': '_d_',
    ':': '_c_',
    '%': '_p_',
    ',': '_co_',
    "'": '_q_',
    '"': '_dq_',
    '*': '_a_',
    '&': '_am_',
    '@': '_at_',
    '{': '_bal_',
    '}': '_bar_',
    '+': '_plus_',
    ';': '_se_',
    '<': '_l_',
    '~': '_t_',
    '=': '_e_',
    '>': '_g_',
    '?': '_qu_',
    '^': '_ca_',
    '\`': '_bq_',
    '|': '_b_',
    $: '_do_'
};
const SimpleMappingChars2String = {
    '[': '_',
    ']': '_',
    '(': '_',
    ')': '_',
    '{': '_',
    '}': '_',
    '+': 'a',
    ',': 'b',
    ':': 'c',
    '.': 'd',
    '=': 'e',
    ';': 'f',
    '>': 'g',
    '#': 'h',
    '!': 'i',
    '@': 'j',
    '^': 'k',
    '<': 'l',
    '*': 'm',
    '&': 'n',
    '?': 'o',
    '%': 'p',
    "'": 'q',
    $: 'r',
    '/': 's',
    '~': 't',
    '|': 'u',
    '\`': 'v',
    '\\\\': 'w',
    '"': 'x'
};

function escape(selectors, options = {
    map: SimpleMappingChars2String
}) {
    const { map = SimpleMappingChars2String } = options;
    const sb = selectors.split('');
    for (let i = 0; i < sb.length; i++) {
        const char = sb[i];
        const code = char.charCodeAt(0);
        if (code > 127) {
            sb[i] = 'u' + Number(code).toString(16);
        }
        else {
            const hit = map[char];
            if (hit) {
                sb[i] = hit;
            }
        }
    }
    const res = sb.join('');
    return res;
}

function internalCssSelectorReplacer(selectors, map = SimpleMappingChars2String) {
    return escape(selectors, {
        map
    });
}

const createTransform = (rule, options) => {
    const replaceFlag = options.replaceUniversalSelectorWith !== false;
    const transform = (selectors) => {
        selectors.walk((selector) => {
            if (selector.type === 'universal' && replaceFlag) {
                selector.value = options.replaceUniversalSelectorWith;
            }
            if (selector.type === 'selector') {
                const node = selector.nodes.find((x) => x.type === 'pseudo' && x.value === ':hover');
                node && selector.remove();
            }
            if (selector.type === 'class') {
                selector.value = internalCssSelectorReplacer(selector.value, options.escapeMap);
            }
        });
        if (selectors.length === 0) {
            rule.remove();
        }
    };
    return transform;
};
const getTransformer = (rule, options) => {
    return selectorParser__default["default"](createTransform(rule, options));
};
const transformSync = (rule, options) => {
    const transformer = getTransformer(rule, options);
    return transformer.transformSync(rule, {
        lossless: false,
        updateSelector: true
    });
};

const PATTERNS = [/:not\\(template\\)\\s*~\\s*:not\\(template\\)/.source, /:not\\(\\[hidden\\]\\)\\s*~\\s*:not\\(\\[hidden\\]\\)/.source].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function testIfVariablesScope(node, count = 1) {
    if (/:?:before/.test(node.selector) && /:?:after/.test(node.selector)) {
        for (let i = 0; i < count; i++) {
            const tryTestDecl = node.nodes[i];
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
function commonChunkPreflight(node, options) {
    node.selector = node.selector.replace(BROAD_MATCH_GLOBAL_REGEXP, 'view + view');
    if (testIfVariablesScope(node)) {
        const selectorParts = node.selector.split(',');
        if (!selectorParts.includes('view')) {
            selectorParts.push('view');
        }
        if (options.cssPreflightRange === 'all') {
            if (!selectorParts.includes(':not(not)')) {
                selectorParts.push(':not(not)');
            }
        }
        node.selector = selectorParts.join(',');
        if (typeof options.cssInjectPreflight === 'function') {
            node.append(...options.cssInjectPreflight());
        }
        const pseudoVarRule = new postcss.Rule({
            selector: '::before,::after'
        });
        pseudoVarRule.append(new postcss.Declaration({
            prop: '--tw-content',
            value: '""'
        }));
        node.before(pseudoVarRule);
    }
}

const NS = 'jsx-rename-loader';
const postcssPlugin = 'postcss-weapp-tailwindcss-rename-plugin';
const pluginName = 'weapp-tailwindcss-webpack-plugin';

const postcssWeappTailwindcss = (options = {
    isMainChunk: true
}) => {
    const { customRuleCallback, isMainChunk } = options;
    const flag = typeof customRuleCallback === 'function';
    return {
        postcssPlugin,
        Once(css) {
            css.walkRules((rule) => {
                transformSync(rule, options);
                isMainChunk && commonChunkPreflight(rule, options);
                flag && customRuleCallback(rule, options);
            });
        }
    };
};
postcssWeappTailwindcss.postcss = true;

exports.MappingChars2String = MappingChars2String;
exports.NS = NS;
exports.SimpleMappingChars2String = SimpleMappingChars2String;
exports.escape = escape;
exports.pluginName = pluginName;
exports.postcssWeappTailwindcss = postcssWeappTailwindcss;
",
    "dynamicImports": [],
    "exports": [
      "MappingChars2String",
      "NS",
      "SimpleMappingChars2String",
      "escape",
      "pluginName",
      "postcssWeappTailwindcss",
    ],
    "fileName": "plugin-27708d63.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@csstools/postcss-is-pseudo-class": [],
      "postcss": [
        "Rule",
        "Declaration",
      ],
      "postcss-selector-parser": [
        "default",
      ],
    },
    "imports": [
      "postcss-selector-parser",
      "postcss",
      "@csstools/postcss-is-pseudo-class",
    ],
    "isDynamicEntry": false,
    "isEntry": false,
    "isImplicitEntry": false,
    "map": null,
    "name": "plugin",
    "referencedFiles": [],
    "type": "chunk",
  },
]
`;

exports[`rollup build lib build 2`] = `
[
  {
    "code": "const SYMBOL_TABLE = {
    BACKQUOTE: '\`',
    TILDE: '~',
    EXCLAM: '!',
    AT: '@',
    NUMBERSIGN: '#',
    DOLLAR: '$',
    PERCENT: '%',
    CARET: '^',
    AMPERSAND: '&',
    ASTERISK: '*',
    PARENLEFT: '(',
    PARENRIGHT: ')',
    MINUS: '-',
    UNDERSCORE: '_',
    EQUAL: '=',
    PLUS: '+',
    BRACKETLEFT: '[',
    BRACELEFT: '{',
    BRACKETRIGHT: ']',
    BRACERIGHT: '}',
    SEMICOLON: ';',
    COLON: ':',
    QUOTE: "'",
    DOUBLEQUOTE: '"',
    BACKSLASH: '\\\\',
    BAR: '|',
    COMMA: ',',
    LESS: '<',
    PERIOD: '.',
    GREATER: '>',
    SLASH: '/',
    QUESTION: '?',
    SPACE: ' ',
    DOT: '.',
    HASH: '#'
};
const MappingChars2String = {
    '[': '_bl_',
    ']': '_br_',
    '(': '_pl_',
    ')': '_qr_',
    '#': '_h_',
    '!': '_i_',
    '/': '_s_',
    '\\\\': '_bs_',
    '.': '_d_',
    ':': '_c_',
    '%': '_p_',
    ',': '_co_',
    "'": '_q_',
    '"': '_dq_',
    '*': '_a_',
    '&': '_am_',
    '@': '_at_',
    '{': '_bal_',
    '}': '_bar_',
    '+': '_plus_',
    ';': '_se_',
    '<': '_l_',
    '~': '_t_',
    '=': '_e_',
    '>': '_g_',
    '?': '_qu_',
    '^': '_ca_',
    '\`': '_bq_',
    '|': '_b_',
    $: '_do_'
};
const MappingChars2StringEntries = Object.entries(MappingChars2String);
const SimpleMappingChars2String = {
    '[': '_',
    ']': '_',
    '(': '_',
    ')': '_',
    '{': '_',
    '}': '_',
    '+': 'a',
    ',': 'b',
    ':': 'c',
    '.': 'd',
    '=': 'e',
    ';': 'f',
    '>': 'g',
    '#': 'h',
    '!': 'i',
    '@': 'j',
    '^': 'k',
    '<': 'l',
    '*': 'm',
    '&': 'n',
    '?': 'o',
    '%': 'p',
    "'": 'q',
    $: 'r',
    '/': 's',
    '~': 't',
    '|': 'u',
    '\`': 'v',
    '\\\\': 'w',
    '"': 'x'
};
const SimpleMappingChars2StringEntries = Object.entries(SimpleMappingChars2String);

function escape(selectors, options = {
    map: SimpleMappingChars2String
}) {
    const { map = SimpleMappingChars2String } = options;
    const sb = selectors.split('');
    for (let i = 0; i < sb.length; i++) {
        const char = sb[i];
        const code = char.charCodeAt(0);
        if (code > 127) {
            sb[i] = 'u' + Number(code).toString(16);
        }
        else {
            const hit = map[char];
            if (hit) {
                sb[i] = hit;
            }
        }
    }
    const res = sb.join('');
    return res;
}

function replaceWxml(original, options = {
    keepEOL: false,
    escapeMap: SimpleMappingChars2String
}) {
    if (typeof options === 'boolean') {
        options = {
            keepEOL: options
        };
    }
    let res = original;
    if (!options.keepEOL) {
        res = res
            .replace(/[\\r\\n]+/g, '');
    }
    res = escape(res, {
        map: options.escapeMap
    });
    return res;
}

function internalCssSelectorReplacer(selectors, map = SimpleMappingChars2String) {
    return escape(selectors, {
        map
    });
}

export { MappingChars2String, MappingChars2StringEntries, SYMBOL_TABLE, SimpleMappingChars2String, SimpleMappingChars2StringEntries, internalCssSelectorReplacer as replaceCss, replaceWxml as replaceJs };
",
    "dynamicImports": [],
    "exports": [
      "MappingChars2String",
      "MappingChars2StringEntries",
      "SYMBOL_TABLE",
      "SimpleMappingChars2String",
      "SimpleMappingChars2StringEntries",
      "replaceCss",
      "replaceJs",
    ],
    "fileName": "replace.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {},
    "imports": [],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "replace",
    "referencedFiles": [],
    "type": "chunk",
  },
]
`;

exports[`rollup build lib build 3`] = `
[
  {
    "code": "'use strict';

var micromatch = require('micromatch');
var generate = require('@babel/generator');
var parser = require('@babel/parser');
var traverse = require('@babel/traverse');
var t = require('@babel/types');
var postcss = require('postcss');
var selectorParser = require('postcss-selector-parser');
var postcssIsPseudoClass = require('@csstools/postcss-is-pseudo-class');
var path = require('path');
var fs = require('fs');
var semver = require('semver');
var tailwindcssPatch = require('tailwindcss-patch');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var generate__default = /*#__PURE__*/_interopDefault(generate);
var traverse__default = /*#__PURE__*/_interopDefault(traverse);
var t__namespace = /*#__PURE__*/_interopNamespace(t);
var postcss__default = /*#__PURE__*/_interopDefault(postcss);
var selectorParser__default = /*#__PURE__*/_interopDefault(selectorParser);
var postcssIsPseudoClass__default = /*#__PURE__*/_interopDefault(postcssIsPseudoClass);
var path__default = /*#__PURE__*/_interopDefault(path);
var fs__default = /*#__PURE__*/_interopDefault(fs);

function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? \`\${namespace}.\` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

function isRegexp(value) {
    return Object.prototype.toString.call(value) === '[object RegExp]';
}
function isMap(value) {
    return Object.prototype.toString.call(value) === '[object Map]';
}
const noop = () => { };
function groupBy(arr, cb) {
    if (!Array.isArray(arr)) {
        throw new Error('expected an array for first argument');
    }
    if (typeof cb !== 'function') {
        throw new Error('expected a function for second argument');
    }
    const result = {};
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const bucketCategory = cb(item);
        const bucket = result[bucketCategory];
        if (!Array.isArray(bucket)) {
            result[bucketCategory] = [item];
        }
        else {
            result[bucketCategory].push(item);
        }
    }
    return result;
}
function getGroupedEntries(entries, options) {
    const { cssMatcher, htmlMatcher, jsMatcher } = options;
    const groupedEntries = groupBy(entries, ([file]) => {
        if (cssMatcher(file)) {
            return 'css';
        }
        else if (htmlMatcher(file)) {
            return 'html';
        }
        else if (jsMatcher(file)) {
            return 'js';
        }
        else {
            return 'other';
        }
    });
    return groupedEntries;
}

const MappingChars2String = {
    '[': '_bl_',
    ']': '_br_',
    '(': '_pl_',
    ')': '_qr_',
    '#': '_h_',
    '!': '_i_',
    '/': '_s_',
    '\\\\': '_bs_',
    '.': '_d_',
    ':': '_c_',
    '%': '_p_',
    ',': '_co_',
    "'": '_q_',
    '"': '_dq_',
    '*': '_a_',
    '&': '_am_',
    '@': '_at_',
    '{': '_bal_',
    '}': '_bar_',
    '+': '_plus_',
    ';': '_se_',
    '<': '_l_',
    '~': '_t_',
    '=': '_e_',
    '>': '_g_',
    '?': '_qu_',
    '^': '_ca_',
    '\`': '_bq_',
    '|': '_b_',
    $: '_do_'
};
const SimpleMappingChars2String = {
    '[': '_',
    ']': '_',
    '(': '_',
    ')': '_',
    '{': '_',
    '}': '_',
    '+': 'a',
    ',': 'b',
    ':': 'c',
    '.': 'd',
    '=': 'e',
    ';': 'f',
    '>': 'g',
    '#': 'h',
    '!': 'i',
    '@': 'j',
    '^': 'k',
    '<': 'l',
    '*': 'm',
    '&': 'n',
    '?': 'o',
    '%': 'p',
    "'": 'q',
    $: 'r',
    '/': 's',
    '~': 't',
    '|': 'u',
    '\`': 'v',
    '\\\\': 'w',
    '"': 'x'
};

function escape(selectors, options = {
    map: SimpleMappingChars2String
}) {
    const { map = SimpleMappingChars2String } = options;
    const sb = selectors.split('');
    for (let i = 0; i < sb.length; i++) {
        const char = sb[i];
        const code = char.charCodeAt(0);
        if (code > 127) {
            sb[i] = 'u' + Number(code).toString(16);
        }
        else {
            const hit = map[char];
            if (hit) {
                sb[i] = hit;
            }
        }
    }
    const res = sb.join('');
    return res;
}

function replaceWxml(original, options = {
    keepEOL: false,
    escapeMap: SimpleMappingChars2String
}) {
    if (typeof options === 'boolean') {
        options = {
            keepEOL: options
        };
    }
    let res = original;
    if (!options.keepEOL) {
        res = res
            .replace(/[\\r\\n]+/g, '');
    }
    res = escape(res, {
        map: options.escapeMap
    });
    return res;
}

function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    }
    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');
}
const templateClassExactRegexp = /(?:(?<=^|\\s)(?:hover-)?class)=(?:["']\\W+\\s*(?:\\w+)\\()?["']([^"]+)['"]/gs;
const tagWithEitherClassAndHoverClassRegexp = /<(?:[a-z][-a-z]*[a-z]*)\\s+[^>]*?(?:(?:hover-)?class="(?:[^"]*)")[^>]*?\\/?>/g;
function handleRegexp(reg) {
    return \`(?:\${reg.source})\`;
}
function getSourceString(input) {
    let result;
    if (typeof input === 'string') {
        result = input;
    }
    else if (isRegexp(input)) {
        result = input.source;
    }
    else {
        result = input.toString();
    }
    return result;
}
function makePattern(arr) {
    let pattern = '';
    if (Array.isArray(arr)) {
        pattern = arr
            .reduce((acc, cur) => {
            if (typeof cur === 'string') {
                acc.push(cur);
            }
            else if (isRegexp(cur)) {
                acc.push(handleRegexp(cur));
            }
            return acc;
        }, [])
            .join('|');
    }
    else if (typeof arr === 'string') {
        pattern = arr;
    }
    else if (isRegexp(arr)) {
        pattern = handleRegexp(arr);
    }
    return pattern;
}
function createTempleteHandlerMatchRegexp(tag, attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\\\s)' : '';
    const pattern = makePattern(attrs);
    let tagPattern = getSourceString(tag);
    if (tagPattern === '*') {
        tagPattern = '[a-z][-a-z]*[a-z]*';
    }
    const source = \`<(\${tagPattern})\\\\s+[^>]*?(?:\${prefix}(\${pattern})="(?:[^"]*)")[^>]*?\\\\/?>\`;
    return new RegExp(source, 'g');
}
function createTemplateClassRegexp(attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\\\s)' : '';
    const pattern = makePattern(attrs);
    const source = \`(?:\${prefix}\${pattern})=(?:["']\\\\W+\\\\s*(?:\\\\w+)\\\\()?["']([^"]+)['"]\`;
    return new RegExp(source, 'gs');
}
function makeCustomAttributes(entries) {
    if (Array.isArray(entries)) {
        return entries.map(([k, v]) => {
            return {
                tagRegexp: createTempleteHandlerMatchRegexp(k, v),
                attrRegexp: createTemplateClassRegexp(v),
                tag: getSourceString(k),
                attrs: v
            };
        });
    }
}
const variableRegExp = /{{(.*?)}}/gs;
function variableMatch(original) {
    return variableRegExp.exec(original);
}

function generateCode(match, options = {}) {
    const ast = parser.parseExpression(match);
    traverse__default.default(ast, {
        StringLiteral(path) {
            var _a;
            if (t__namespace.isMemberExpression(path.parent)) {
                return;
            }
            if (t__namespace.isBinaryExpression(path.parent)) {
                if (t__namespace.isConditionalExpression((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent)) {
                    return;
                }
            }
            path.node.value = replaceWxml(path.node.value, options);
        },
        noScope: true
    });
    const { code } = generate__default.default(ast, {
        compact: true,
        minified: true,
        jsescOption: {
            quotes: 'single',
            minimal: true
        }
    });
    return code;
}
function extractSource(original) {
    let match = variableMatch(original);
    const sources = [];
    while (match !== null) {
        const start = match.index;
        const end = variableRegExp.lastIndex;
        sources.push({
            start,
            end,
            raw: match[1],
            prevConcatenated: !/\\s/.test(original[start - 1]),
            nextConcatenated: !/\\s/.test(original[end])
        });
        match = variableMatch(original);
    }
    return sources;
}
function templeteReplacer(original, options = {}) {
    const sources = extractSource(original);
    if (sources.length) {
        const resultArray = [];
        let p = 0;
        for (let i = 0; i < sources.length; i++) {
            const m = sources[i];
            const before = original.slice(p, m.start);
            resultArray.push(replaceWxml(before, {
                keepEOL: true,
                escapeMap: options.escapeMap
            }));
            p = m.start;
            if (m.raw.trim().length) {
                const code = generateCode(m.raw, options);
                const source = \`{{\${code}}}\`;
                m.source = source;
            }
            else {
                m.source = '';
            }
            resultArray.push(m.source);
            p = m.end;
            if (i === sources.length - 1) {
                const after = original.slice(m.end);
                resultArray.push(replaceWxml(after, {
                    keepEOL: true,
                    escapeMap: options.escapeMap
                }));
            }
        }
        return resultArray
            .filter((x) => x)
            .join('')
            .trim();
    }
    else {
        return replaceWxml(original, {
            keepEOL: false,
            escapeMap: options.escapeMap
        });
    }
}
function templeteHandler(rawSource, options = {}) {
    return rawSource.replace(tagWithEitherClassAndHoverClassRegexp, (m0) => {
        return m0.replace(templateClassExactRegexp, (m1, className) => {
            return m1.replace(className, templeteReplacer(className, options));
        });
    });
}
function customTempleteHandler(rawSource, options = {}) {
    let source = templeteHandler(rawSource, options);
    const regexps = makeCustomAttributes(options.customAttributesEntities);
    if (regexps) {
        if (Array.isArray(regexps)) {
            for (let i = 0; i < regexps.length; i++) {
                const regexp = regexps[i];
                source = source.replace(regexp.tagRegexp, (m0) => {
                    return m0.replace(regexp.attrRegexp, (m1, className) => {
                        return m1.replace(className, templeteReplacer(className, options));
                    });
                });
            }
        }
        return source;
    }
    else {
        return source;
    }
}
function createTempleteHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTempleteHandler(rawSource, defu(opt, options));
    };
}

function internalCssSelectorReplacer(selectors, map = SimpleMappingChars2String) {
    return escape(selectors, {
        map
    });
}

const createTransform = (rule, options) => {
    const replaceFlag = options.replaceUniversalSelectorWith !== false;
    const transform = (selectors) => {
        selectors.walk((selector) => {
            if (selector.type === 'universal' && replaceFlag) {
                selector.value = options.replaceUniversalSelectorWith;
            }
            if (selector.type === 'selector') {
                const node = selector.nodes.find((x) => x.type === 'pseudo' && x.value === ':hover');
                node && selector.remove();
            }
            if (selector.type === 'class') {
                selector.value = internalCssSelectorReplacer(selector.value, options.escapeMap);
            }
        });
        if (selectors.length === 0) {
            rule.remove();
        }
    };
    return transform;
};
const getTransformer = (rule, options) => {
    return selectorParser__default.default(createTransform(rule, options));
};
const transformSync = (rule, options) => {
    const transformer = getTransformer(rule, options);
    return transformer.transformSync(rule, {
        lossless: false,
        updateSelector: true
    });
};

const PATTERNS = [/:not\\(template\\)\\s*~\\s*:not\\(template\\)/.source, /:not\\(\\[hidden\\]\\)\\s*~\\s*:not\\(\\[hidden\\]\\)/.source].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function testIfVariablesScope(node, count = 1) {
    if (/:?:before/.test(node.selector) && /:?:after/.test(node.selector)) {
        for (let i = 0; i < count; i++) {
            const tryTestDecl = node.nodes[i];
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
function commonChunkPreflight(node, options) {
    node.selector = node.selector.replace(BROAD_MATCH_GLOBAL_REGEXP, 'view + view');
    if (testIfVariablesScope(node)) {
        const selectorParts = node.selector.split(',');
        if (!selectorParts.includes('view')) {
            selectorParts.push('view');
        }
        if (options.cssPreflightRange === 'all') {
            if (!selectorParts.includes(':not(not)')) {
                selectorParts.push(':not(not)');
            }
        }
        node.selector = selectorParts.join(',');
        if (typeof options.cssInjectPreflight === 'function') {
            node.append(...options.cssInjectPreflight());
        }
        const pseudoVarRule = new postcss.Rule({
            selector: '::before,::after'
        });
        pseudoVarRule.append(new postcss.Declaration({
            prop: '--tw-content',
            value: '""'
        }));
        node.before(pseudoVarRule);
    }
}

const postcssPlugin = 'postcss-weapp-tailwindcss-rename-plugin';
const vitePluginName = 'vite-plugin-uni-app-weapp-tailwindcss-adaptor';

const postcssWeappTailwindcss = (options = {
    isMainChunk: true
}) => {
    const { customRuleCallback, isMainChunk } = options;
    const flag = typeof customRuleCallback === 'function';
    return {
        postcssPlugin,
        Once(css) {
            css.walkRules((rule) => {
                transformSync(rule, options);
                isMainChunk && commonChunkPreflight(rule, options);
                flag && customRuleCallback(rule, options);
            });
        }
    };
};
postcssWeappTailwindcss.postcss = true;

function styleHandler(rawSource, options) {
    return postcss__default.default([postcssWeappTailwindcss(options), postcssIsPseudoClass__default.default()]).process(rawSource).css;
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defu(opt, options));
    };
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (let i = 0; i < entries.length; i++) {
            const [prop, value] = entries[i];
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString()
                });
            }
        }
    }
    return () => {
        return result;
    };
};

function findAstNode(content, options) {
    const DOPTS = options.dangerousOptions;
    const ast = parser.parse(content);
    let arrayRef;
    let changed = false;
    traverse__default.default(ast, {
        Identifier(path) {
            if (path.node.name === DOPTS.variableName) {
                if (t__namespace.isVariableDeclarator(path.parent)) {
                    if (t__namespace.isArrayExpression(path.parent.init)) {
                        arrayRef = path.parent.init;
                        const set = new Set(path.parent.init.elements.map((x) => x.value));
                        for (let i = 0; i < options.units.length; i++) {
                            const unit = options.units[i];
                            if (!set.has(unit)) {
                                path.parent.init.elements = path.parent.init.elements.map((x) => {
                                    if (t__namespace.isStringLiteral(x)) {
                                        return {
                                            type: x === null || x === void 0 ? void 0 : x.type,
                                            value: x === null || x === void 0 ? void 0 : x.value
                                        };
                                    }
                                    return x;
                                });
                                path.parent.init.elements.push({
                                    type: 'StringLiteral',
                                    value: unit
                                });
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    });
    return {
        arrayRef,
        changed
    };
}

function getInstalledPkgJsonPath(options) {
    const dangerousOptions = options.dangerousOptions;
    try {
        const tmpJsonPath = tailwindcssPatch.requireResolve(\`\${dangerousOptions.packageName}/package.json\`, {
            paths: options.paths,
            basedir: options.basedir
        });
        return tmpJsonPath;
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.warn('没有找到\`tailwindcss\`包，请确认是否安装。想要禁用打上rpx支持patch或者非\`tailwindcss\`框架，你可以设置 \`supportCustomLengthUnitsPatch\` 为 false');
        }
    }
}
function createPatch(options) {
    if (options === false) {
        return noop;
    }
    return () => {
        try {
            return internalPatch(getInstalledPkgJsonPath(options), options);
        }
        catch (error) {
            console.warn(\`patch tailwindcss failed:\` + error.message);
        }
    };
}
function monkeyPatchForSupportingCustomUnit(rootDir, options) {
    var _a;
    const { dangerousOptions } = options;
    const DOPTS = dangerousOptions;
    const dataTypesFilePath = path__default.default.resolve(rootDir, DOPTS.lengthUnitsFilePath);
    const dataTypesFileContent = fs__default.default.readFileSync(dataTypesFilePath, {
        encoding: 'utf-8'
    });
    const { arrayRef, changed } = findAstNode(dataTypesFileContent, options);
    if (arrayRef && changed) {
        const { code } = generate__default.default(arrayRef, {
            jsescOption: {
                quotes: 'single'
            }
        });
        if (arrayRef.start && arrayRef.end) {
            const prev = dataTypesFileContent.slice(0, arrayRef.start);
            const next = dataTypesFileContent.slice(arrayRef.end);
            const newCode = prev + code + next;
            if (DOPTS.overwrite) {
                fs__default.default.writeFileSync((_a = DOPTS.destPath) !== null && _a !== void 0 ? _a : dataTypesFilePath, newCode, {
                    encoding: 'utf-8'
                });
                console.log('patch tailwindcss for custom length unit successfully!');
            }
        }
        return code;
    }
}
function internalPatch(pkgJsonPath, options, overwrite = true) {
    if (pkgJsonPath) {
        const pkgJson = require(pkgJsonPath);
        const dangerousOptions = options.dangerousOptions;
        if (semver.gte(pkgJson.version, dangerousOptions.gteVersion)) {
            const rootDir = path__default.default.dirname(pkgJsonPath);
            const dataTypes = monkeyPatchForSupportingCustomUnit(rootDir, options);
            const result = tailwindcssPatch.monkeyPatchForExposingContext(rootDir, {
                overwrite
            });
            return Object.assign(Object.assign({}, result), { dataTypes });
        }
    }
}
function createTailwindcssPatcher() {
    return new tailwindcssPatch.TailwindcssPatcher({
        cache: true
    });
}

const validateFilterRE = /[\\w\\u00A0-\\uFFFF-_:%-?]/;
function isValidSelector(selector = '') {
    return validateFilterRE.test(selector);
}
const splitCode = (code) => {
    return code.split(/[\\s]+/).filter(isValidSelector);
};

const isProd = () => process.env.NODE_ENV === 'production';

function handleValue(str, node, options) {
    const set = options.classNameSet;
    const escapeMap = options.escapeMap;
    const arr = splitCode(str);
    let rawStr = str;
    for (let i = 0; i < arr.length; i++) {
        const v = arr[i];
        if (set.has(v)) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                rawStr = rawStr.replace(new RegExp(escapeStringRegexp(v), 'g'), replaceWxml(v, {
                    escapeMap
                }));
            }
        }
    }
    return rawStr;
}
function jsHandler(rawSource, options) {
    var _a;
    const ast = parser.parse(rawSource, {
        sourceType: 'unambiguous'
    });
    const topt = {
        StringLiteral: {
            enter(p) {
                const n = p.node;
                n.value = handleValue(n.value, n, options);
            }
        },
        TemplateElement: {
            enter(p) {
                const n = p.node;
                n.value.raw = handleValue(n.value.raw, n, options);
            }
        },
        CallExpression: {
            enter(p) {
                const n = p.node;
                if (t__namespace.isIdentifier(n.callee) && n.callee.name === 'eval') {
                    if (t__namespace.isStringLiteral(n.arguments[0])) {
                        const res = jsHandler(n.arguments[0].value, options);
                        if (res.code) {
                            n.arguments[0].value = res.code;
                        }
                    }
                }
            }
        },
        noScope: true
    };
    traverse__default.default(ast, topt);
    return generate__default.default(ast, {
        minified: (_a = options.minifiedJs) !== null && _a !== void 0 ? _a : isProd()
    });
}
function createjsHandler(options) {
    return (rawSource, set) => {
        return jsHandler(rawSource, {
            classNameSet: set,
            minifiedJs: options.minifiedJs,
            escapeMap: options.escapeMap
        });
    };
}

const defaultOptions = {
    cssMatcher: (file) => /.+\\.(?:wx|ac|jx|tt|q|c)ss$/.test(file),
    htmlMatcher: (file) => /.+\\.(?:(?:(?:wx|ax|jx|ks|tt|q)ml)|swan)$/.test(file),
    jsMatcher: (file) => {
        if (file.includes('node_modules')) {
            return false;
        }
        return /.+\\.[cm]?[jt]sx?$/.test(file);
    },
    mainCssChunkMatcher: (file, appType) => {
        switch (appType) {
            case 'uni-app': {
                return /^common\\/main/.test(file);
            }
            case 'uni-app-vite': {
                return /^app/.test(file) || /^common\\/main/.test(file);
            }
            case 'mpx': {
                return /^app/.test(file);
            }
            case 'taro': {
                return /^app/.test(file);
            }
            case 'remax': {
                return /^app/.test(file);
            }
            case 'rax': {
                return /^bundle/.test(file);
            }
            case 'native': {
                return /^app/.test(file);
            }
            case 'kbone': {
                return /^(?:common\\/)?miniprogram-app/.test(file);
            }
            default: {
                return true;
            }
        }
    },
    cssPreflight: {
        'box-sizing': 'border-box',
        'border-width': '0',
        'border-style': 'solid',
        'border-color': 'currentColor'
    },
    cssPreflightRange: 'view',
    replaceUniversalSelectorWith: 'view',
    disabled: false,
    customRuleCallback: noop,
    onLoad: noop,
    onStart: noop,
    onEnd: noop,
    onUpdate: noop,
    customAttributes: {},
    customReplaceDictionary: SimpleMappingChars2String,
    supportCustomLengthUnitsPatch: {
        units: ['rpx'],
        dangerousOptions: {
            gteVersion: '3.0.0',
            lengthUnitsFilePath: 'lib/util/dataTypes.js',
            packageName: 'tailwindcss',
            variableName: 'lengthUnits',
            overwrite: true
        }
    },
    appType: undefined
};

function createGlobMatcher(pattern) {
    return function (file) {
        return micromatch.isMatch(file, pattern);
    };
}
function normalizeMatcher(options, key) {
    if (typeof options[key] === 'string' || Array.isArray(options[key])) {
        options[key] = createGlobMatcher(options[key]);
    }
}
function getOptions(options = {}, modules = ['style', 'templete', 'patch', 'js']) {
    const registerModules = modules.reduce((acc, cur) => {
        if (acc[cur] !== undefined) {
            acc[cur] = true;
        }
        return acc;
    }, {
        templete: false,
        style: false,
        patch: false,
        js: false
    });
    if (options.supportCustomLengthUnitsPatch === true) {
        options.supportCustomLengthUnitsPatch = undefined;
    }
    if (options.customReplaceDictionary === 'simple') {
        options.customReplaceDictionary = SimpleMappingChars2String;
    }
    else if (options.customReplaceDictionary === 'complex') {
        options.customReplaceDictionary = MappingChars2String;
    }
    normalizeMatcher(options, 'cssMatcher');
    normalizeMatcher(options, 'htmlMatcher');
    normalizeMatcher(options, 'jsMatcher');
    normalizeMatcher(options, 'mainCssChunkMatcher');
    const result = defu(options, defaultOptions, {
        minifiedJs: isProd()
    });
    const { cssPreflight, customRuleCallback, cssPreflightRange, replaceUniversalSelectorWith, customAttributes, customReplaceDictionary, supportCustomLengthUnitsPatch } = result;
    result.escapeMap = customReplaceDictionary;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    let customAttributesEntities;
    if (isMap(options.customAttributes)) {
        customAttributesEntities = Array.from(options.customAttributes.entries());
    }
    else {
        customAttributesEntities = Object.entries(customAttributes);
    }
    if (registerModules.templete) {
        result.templeteHandler = createTempleteHandler({
            customAttributesEntities,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.style) {
        result.styleHandler = createStyleHandler({
            cssInjectPreflight,
            customRuleCallback,
            cssPreflightRange,
            replaceUniversalSelectorWith,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.js) {
        result.jsHandler = createjsHandler({
            minifiedJs: result.minifiedJs,
            escapeMap: result.escapeMap
        });
    }
    if (registerModules.patch) {
        result.patch = createPatch(supportCustomLengthUnitsPatch);
    }
    return result;
}

function UnifiedViteWeappTailwindcssPlugin(options = {}) {
    if (typeof options.customReplaceDictionary === 'undefined') {
        options.customReplaceDictionary = 'simple';
    }
    const opts = getOptions(options, ['patch', 'style', 'templete', 'js']);
    const { disabled, onEnd, onLoad, onStart, onUpdate, templeteHandler, styleHandler, patch, jsHandler, mainCssChunkMatcher, appType } = opts;
    if (disabled) {
        return;
    }
    patch === null || patch === void 0 ? void 0 : patch();
    const twPatcher = createTailwindcssPatcher();
    onLoad();
    return {
        name: vitePluginName,
        enforce: 'post',
        buildStart() {
            onStart();
        },
        generateBundle(opt, bundle, isWrite) {
            const entries = Object.entries(bundle);
            const groupedEntries = getGroupedEntries(entries, opts);
            if (Array.isArray(groupedEntries.html)) {
                for (let i = 0; i < groupedEntries.html.length; i++) {
                    const [file, originalSource] = groupedEntries.html[i];
                    const oldVal = originalSource.source.toString();
                    originalSource.source = templeteHandler(oldVal);
                    onUpdate(file, oldVal, originalSource.source);
                }
            }
            if (Array.isArray(groupedEntries.css)) {
                for (let i = 0; i < groupedEntries.css.length; i++) {
                    const [file, originalSource] = groupedEntries.css[i];
                    const rawSource = originalSource.source.toString();
                    const css = styleHandler(rawSource, {
                        isMainChunk: mainCssChunkMatcher(originalSource.fileName, appType)
                    });
                    originalSource.source = css;
                    onUpdate(file, rawSource, css);
                }
            }
            if (Array.isArray(groupedEntries.js)) {
                const set = twPatcher.getClassSet();
                for (let i = 0; i < groupedEntries.js.length; i++) {
                    const [file, originalSource] = groupedEntries.js[i];
                    const rawSource = originalSource.code;
                    const { code } = jsHandler(rawSource, set);
                    originalSource.code = code;
                    onUpdate(file, rawSource, code);
                }
            }
        },
        buildEnd() {
            onEnd();
        }
    };
}

exports.UnifiedViteWeappTailwindcssPlugin = UnifiedViteWeappTailwindcssPlugin;
",
    "dynamicImports": [],
    "exports": [
      "UnifiedViteWeappTailwindcssPlugin",
    ],
    "fileName": "vite.js",
    "implicitlyLoadedBefore": [],
    "importedBindings": {
      "@babel/generator": [
        "default",
      ],
      "@babel/parser": [
        "parseExpression",
        "parse",
      ],
      "@babel/traverse": [
        "default",
      ],
      "@babel/types": [
        "*",
      ],
      "@csstools/postcss-is-pseudo-class": [
        "default",
      ],
      "fs": [
        "default",
      ],
      "micromatch": [
        "isMatch",
      ],
      "path": [
        "default",
      ],
      "postcss": [
        "Rule",
        "Declaration",
        "default",
      ],
      "postcss-selector-parser": [
        "default",
      ],
      "semver": [
        "gte",
      ],
      "tailwindcss-patch": [
        "TailwindcssPatcher",
        "monkeyPatchForExposingContext",
        "requireResolve",
      ],
    },
    "imports": [
      "micromatch",
      "@babel/generator",
      "@babel/parser",
      "@babel/traverse",
      "@babel/types",
      "postcss",
      "postcss-selector-parser",
      "@csstools/postcss-is-pseudo-class",
      "path",
      "fs",
      "semver",
      "tailwindcss-patch",
    ],
    "isDynamicEntry": false,
    "isEntry": true,
    "isImplicitEntry": false,
    "map": null,
    "name": "index",
    "referencedFiles": [],
    "type": "chunk",
  },
]
`;
